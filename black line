# importing packages and initialisng 
from re import I
from turtle import back, color
import pygame
import math
import time
import collections
#import numpy as np
pygame.init()

# setting up pygame visualistation window (width and height of window, as well as window title)
width, height = 600, 600
pygame_window = pygame.display.set_mode((width, height))
pygame.display.set_caption("Travel to Pluto")
#disappearing_line = time.process_time() + 0.01

# defining colours
yellow = (255,255,0)
blue = (100, 149, 237)
red = (188, 39, 50)
grey = (80, 78, 81)
white = (255, 255, 255)
black = (0, 0, 0)

# setting font
font = pygame.font.SysFont("Arial", 12)
i = 0


# creating a planet class
class Planet:
    AU = 149.6e6*1000 # astronomical unit in metres
    G = 6.67428e-11 # gravitational constant
    scale = 250 / AU # 1AU = 100px
    timestep = 3600*24 # seconds in a day (this is how much movement is updated every 60 FPS)

    # initialisation of class asstributes
    def __init__(self, x, y, radius, color, mass):
        self.x = x
        self.y = y
        self.radius = radius
        self.color = color
        self.mass = mass

        # initial velocity
        self.x_v = 0
        self.y_v = 0

        self.sun = False # the sun isn't a planet
        self.distance_to_sun = 0
        self.orbit = [] # array of orbit paths


    def draw(self, win):
        # centering
        x = self.x * self.scale + width / 2
        y = self.y * self.scale + height / 2

        global i
        run_once = 0

        updated_points = []
        sliced_points= []

        # drawing the orbit lines if there are more than two position points
        if len(self.orbit) > 2:

            global i
            
            for point in self.orbit:
                x, y = point
                x = x * self.scale + width / 2
                y = y * self.scale + width / 2
                updated_points.append((x,y))
                #print(range(len(updated_points)))
                #print(updated_points)

            pygame.draw.lines(pygame_window, self.color, False, updated_points, 2) # drawing the orbit lines


            if len(updated_points) > 18:
                pygame.draw.lines(pygame_window, black, False, (updated_points[-18], updated_points[-17]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-17], updated_points[-16]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-16], updated_points[-15]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-15], updated_points[-14]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-14], updated_points[-13]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-13], updated_points[-12]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-12], updated_points[-11]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-11], updated_points[-10]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-10], updated_points[-9]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-9], updated_points[-8]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-8], updated_points[-7]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-7], updated_points[-6]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-6], updated_points[-5]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-5], updated_points[-4]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-4], updated_points[-3]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-3], updated_points[-2]), 5)
                pygame.draw.lines(pygame_window, black, False, (updated_points[-2], updated_points[-1]), 5)


                #sliced_points = updated_points[25:len(updated_points):1]
                    #print(sliced_points[0][1])
                    #print(updated_points[25][1])
                #print(updated_points[0][1])
                #print(sliced_points[0][1])
                #print(range(len(sliced_points)))

                #if updated_points[-1][1] == sliced_points[-1][1]:

                    #pygame.draw.lines(pygame_window, white, False, sliced_points, 2) # drawing the orbit lines
                #print(updated_points)
                
                #updated_points_midpoint = np.median(updated_points) makes code run very slowly
            
            #def middle_element(updated_points):
               # if len(updated_points) % 2 != 0:
                   # return updated_points[int(len(updated_points) / 2)]
              #  else:
                   # return (((updated_points[int(len(updated_points) / 2)]) + (updated_points[int(len(updated_points) / 2) - 1])) / 2)
            
            #for x,y in updated_points:
                #backtrace.append((x-30,y-30))

            
            #if len(sliced_points) > 2:
            
            

                
            #time.sleep(0.01)
                
            #for x,y in updated_points:
            #if len(updated_points) > 30:
                    
                    #backtrace= collections.deque(updated_points)
                    #backtrace.rotate(2)

                    #print(range(len(updated_points)))

                    #print( "x equals", x)
                    #print(backtrace)

                    #fifth_position_x = updated_points[5+i][0]
                    #fifth_position_y = updated_points[5+i][1]


                    #updated_points[5+i][0], updated_points[5+i][1]

                #while len(backtrace) < len(updated_points):
                    #print(5+i)

                    #if run_once == 0:
                        #fifth_position_x = updated_points[5][0]
                        #fifth_position_y = updated_points[5][1]
                        #sixth_position_x = updated_points[6][0]
                        #sixth_position_y = updated_points[6][1]
                        #print(fifth_position_x)
                        #print(fifth_position_y)
                        #print(sixth_position_x)
                        #print(sixth_position_y)
                        #backtrace.append((fifth_position_x, fifth_position_y))
                        #backtrace.append((sixth_position_x, sixth_position_y))
                        #run_once = 1
                    
                    #if len(backtrace) < len(updated_points):
                    #update_position_x = updated_points[6+i][0]
                    #update_position_y = updated_points[6+i][1]
                    #update_position_xx = updated_points[6+i-1][0]
                    #update_position_yy = updated_points[6+i-1][1]

                    #print(backtrace)

                    #backtrace.append((update_position_x, update_position_y))
                    #backtrace.append((update_position_xx, update_position_yy))


                    #print(backtrace)
                    #print(updated_points)
                    #if time.process_time() > disappearing_line:
                    #if len(backtrace) > 2:
                        #pygame.draw.lines(pygame_window, white, False, backtrace, 2) # drawing the orbit lines

                        #i += 1
                    
                

        pygame.draw.circle(win, self.color, (x,y), self.radius) # drawing the planets

        # displaying the distance to the sun on the planets as they move
        if not self.sun:
            distance_text = font.render(f"{round(self.distance_to_sun/1000, 1)}km", 1, white)
            # setting the text position to be in the centre of the planets
            win.blit(distance_text,(x-distance_text.get_width()/2, y+distance_text.get_height()))
   
    def grav_attraction(self, other_body):
        other_body_x, other_body_y = other_body.x, other_body.y
        # x and y distances between two bodies
        distance_x = other_body_x - self.x
        distance_y = other_body_y - self.y
        distance = math.sqrt(distance_x ** 2 + distance_y ** 2) # distance between bodies
        
        if other_body.sun:
            self.distance_to_sun = distance

        # calculation of graviational force, force components, and theta    
        F = self.G * self.mass * other_body.mass / distance**2
        theta = math.atan2(distance_y, distance_x)
        F_x = math.cos(theta) * F
        F_y = math.sin(theta) * F
        return F_x, F_y

    # updating planet positions considering the graviational force
    def update_position(self, planets):
        F_x_net = F_y_net = 0 # inital force on planet is zero
        # calculating the total force on the planet from all the other planets (and sun)
        for planet in planets:
            if self == planet: # don't calculate the force with the planet and itself
                continue

            fx, fy = self.grav_attraction(planet) # taking F_x and F_y from grav_attraction
            # summing the forces
            F_x_net += fx
            F_y_net += fy

        # F=ma velocity calculation
        self.x_v += F_x_net / self.mass * self.timestep
        self.y_v += F_y_net / self.mass * self.timestep

        # position calculation
        self.x += self.x_v * self.timestep
        self.y += self.y_v * self.timestep
        
        # appending x and y positions of orbits
        self.orbit.append((self.x, self.y))

# creating pygame event loop to keep the visualtion window open while the simulation is running

def window_loop():
    running = True
    clock = pygame.time.Clock()

    # sun and planets initialisation (x, y, radius, color, mass)
    sun = Planet(0,0, 30, yellow, 1.98892*10**30)
    sun.sun = True

    earth = Planet(1*Planet.AU, 0, 16, blue, 5.9742*10**24)
    earth.y_v = -29.783 * 1000 #negative to make planet orbit counter-clockwise
    
    mars = Planet(1.524 * Planet.AU, 0, 12, red, 6.39 * 10**23)
    mars.y_v = -24.077 * 1000

    mercury = Planet(0.387 * Planet.AU, 0, 8, grey, 3.30 * 10**23)
    mercury.y_v = -47.4 * 1000

    venus = Planet(0.723 * Planet.AU, 0, 14, white, 4.8685 * 10**24)
    venus.y_v = -35.02 * 1000
    
    planets = [sun, earth, mars, mercury, venus]

    while running:
        clock.tick(30) # set frame rate to 60 FPS
        pygame_window.fill((0,0,0)) # so planets don't have a planet size trail
        # until the user closes the window, continue running the visualisation
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        for planet in planets:
            planet.update_position(planets)
            planet.draw(pygame_window)
        
        pygame.display.update() # continuously update the display

    pygame.quit()

# call the function
window_loop()

